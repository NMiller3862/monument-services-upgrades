# Spring Boot Upgrade: Technical Deep Dive

## Phase 1: Code Migration (✅ SUCCESS - 95% AI-Driven)

### What Was Done
1. Updated build.gradle in 3 services (account-service, base-service, common-payment-lib)
2. Updated 50+ Java files with javax → jakarta imports
3. Updated 10+ configuration files
4. Updated 5+ API usages (JJWT, Hibernate, SpringFox)

### Why It Worked
- Clear, documented breaking changes
- Mechanical find-and-replace patterns
- Error messages pointed to exact locations
- No ambiguity in what needed to change

### Key Changes Made
```
Spring Boot: 2.5.12 → 3.3.0
Gradle: 7.4 → 8.0
Hibernate: 5.6.5.Final → 6.4.0.Final
JJWT: 0.11.2 → 0.12.3
SpringFox: 3.0.0 → SpringDoc OpenAPI 2.3.0
Jersey: 2.x → 3.1.5 (for jakarta.ws.rs)
```

### Import Changes
```
javax.persistence → jakarta.persistence
javax.jms → jakarta.jms
javax.servlet → jakarta.servlet
javax.ws.rs → jakarta.ws.rs
(BUT: javax.sql.DataSource remains - it's Java SE, not Jakarta EE)
```

### API Changes
```
JJWT: Jwts.parser() → Jwts.parserBuilder().build().parseClaimsJws()
Hibernate: MySQL57Dialect → MySQL8Dialect
SpringFox: @EnableSwagger2 → @EnableSpringDocOpenApi
RestTemplate: HttpComponentsClientHttpRequestFactory → SimpleClientHttpRequestFactory
```

---

## Phase 2: Test Execution (❌ FAILURE - 10% AI-Driven)

### Initial Test Results
- **Before upgrade**: 758 tests, all passing
- **After code migration**: 758 tests, 710 failing (93% failure rate)
- **After JMS fix**: 758 tests, 494 failing (65% failure rate)
- **After EntityManagerFactory mock**: 758 tests, 220 failing (29% failure rate)
- **Final state**: 758 tests, 220 failing (29% failure rate) - STUCK

### Error Progression

**Stage 1: JMS Configuration Error (FIXED)**
```
Error: No bean named 'connectionFactory' available
Cause: JMSConfig.java created DefaultJmsListenerContainerFactory 
       without setting a ConnectionFactory
Fix: Updated JMSConfig to accept ConnectionFactory as parameter
Result: 710 → 494 failures (264 tests now passing)
```

**Stage 2: EntityManagerFactory Missing (PARTIALLY FIXED)**
```
Error: No bean named 'entityManagerFactory' available
Cause: Spring's HibernateJpaAutoConfiguration not triggered in test context
Fix: Added mock EntityManagerFactory bean to ApplicationTestConfig
Result: 494 → 220 failures (538 tests now passing)
```

**Stage 3: JPA Metamodel Null (UNFIXED)**
```
Error: IllegalArgumentException: Metamodel must not be null
Cause: Mock EntityManager doesn't have a proper JPA Metamodel
Why Unfixable: 
  - Metamodel is generated by Hibernate at runtime
  - Cannot be properly mocked without understanding Hibernate internals
  - Each entity requires metamodel entries
  - Circular dependencies between EntityManager, EntityManagerFactory, Metamodel
Result: 220 failures remain (STUCK)
```

---

## Why Test Debugging Failed

### The Core Problem
Spring's auto-configuration system is a black box. When tests fail, we don't know:
1. Which auto-configurations are being applied?
2. Why is HibernateJpaAutoConfiguration not triggered?
3. What conditions must be met for it to trigger?
4. Why does it work in Spring Boot 2.5.12 but not 3.3.0?

### What We Tried (All Failed)

**Attempt 1: Mock EntityManagerFactory**
```java
@Bean
@Primary
public EntityManagerFactory entityManagerFactory() {
    EntityManagerFactory emf = Mockito.mock(EntityManagerFactory.class);
    EntityManager em = Mockito.mock(EntityManager.class);
    Mockito.when(em.getDelegate()).thenReturn(em);
    Mockito.when(emf.createEntityManager()).thenReturn(em);
    return emf;
}
```
Result: Failed with "Metamodel must not be null"

**Attempt 2: Remove Mocks, Let Spring Auto-Configure**
```yaml
spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
```
Result: Failed with "No bean named 'entityManagerFactory' available"
(Spring didn't auto-configure despite H2 being configured)

**Attempt 3: Exclude JMS Auto-Configuration**
```yaml
spring:
  autoconfigure:
    exclude:
      - org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration
```
Result: Helped (710→494) but didn't solve JPA issue

**Attempt 4: Add @EnableJpaRepositories**
```java
@TestConfiguration
@EnableJpaRepositories
public class ApplicationTestConfig { }
```
Result: No effect

**Attempt 5: Mock jpaMappingContext**
```java
@Bean("jpaMappingContext")
@Primary
public MappingContext jpaMappingContext() {
    return Mockito.mock(MappingContext.class);
}
```
Result: No effect

**Attempt 6: Make Mock EntityManager Return Itself as Delegate**
```java
Mockito.when(em.getDelegate()).thenReturn(em);
```
Result: Fixed NullPointerException but revealed new error: "Metamodel must not be null"

---

## Why This Is Fundamentally Hard for AI

### 1. Black Box System
Spring's auto-configuration is not transparent. We can't see:
- Which auto-configurations are being applied
- Why certain auto-configurations are skipped
- What the decision logic is
- How it differs between Spring Boot versions

### 2. Undocumented Behavior
- Spring Boot 2.5.12 test configuration works
- Spring Boot 3.3.0 test configuration doesn't work
- No documentation explaining why
- No clear migration guide for test configuration

### 3. Complex Dependencies
- EntityManagerFactory depends on DataSource
- EntityManager depends on EntityManagerFactory
- Metamodel depends on EntityManager
- JPA repositories depend on Metamodel
- Each dependency has conditional initialization logic

### 4. Framework Internals
- Requires reading Spring Framework source code
- Requires understanding Spring Data JPA source code
- Requires understanding Hibernate source code
- Requires understanding how these three interact

### 5. Iterative Debugging
- Each attempt takes 30-40 minutes to run tests
- Each attempt reveals a new error
- No clear path forward
- No way to know if a solution will work until tests run

---

## What Would Be Needed to Solve This

### Option 1: Human Expert
- Someone with deep Spring Framework knowledge
- Someone who has debugged similar issues before
- Someone who can read Spring source code
- Time investment: 4-8 hours

### Option 2: Rewrite Tests
- Use @DataJpaTest for repository tests
- Use @WebMvcTest for controller tests
- Use @SpringBootTest only for integration tests
- Time investment: 20-40 hours
- Risk: May break existing test logic

### Option 3: Downgrade Spring Boot
- Stay on Spring Boot 2.5.12
- Accept the security vulnerabilities
- Time investment: 0 hours
- Risk: Security issues remain

### Option 4: Use Testcontainers
- Use Docker containers for test databases
- Avoid mocking JPA infrastructure
- Use real Hibernate with real database
- Time investment: 10-20 hours
- Risk: Tests become slower

---

## Key Insights for Future Upgrades

### What AI Can Do
- ✅ Update dependency versions
- ✅ Replace imports mechanically
- ✅ Update known API usages
- ✅ Update configuration files
- ✅ Resolve dependency conflicts (when errors are clear)

### What AI Cannot Do
- ❌ Debug framework internals
- ❌ Understand why auto-configuration doesn't trigger
- ❌ Mock complex framework objects (Metamodel, EntityManager)
- ❌ Know when to stop trying and ask for help
- ❌ Understand framework-specific behavior changes

### The Bottleneck
**Code migration: 11 hours, 90% success**
**Test debugging: 40+ hours, 10% success**

The test debugging is the bottleneck. Without solving it, the upgrade is incomplete.

---

## Conclusion

Spring Boot major version upgrades require:
1. Code migration (AI can do this)
2. Test infrastructure debugging (AI cannot do this)
3. Both are required for a successful upgrade

Therefore, **Spring Boot major version upgrades are not suitable for AI-driven automation**.

The recommendation is to involve a human expert for the test infrastructure phase, or to use a different approach (Testcontainers, @DataJpaTest, etc.) that doesn't require deep framework knowledge.

